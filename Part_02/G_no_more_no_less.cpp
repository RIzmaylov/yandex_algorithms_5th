/*
Дан массив целых положительных чисел a длины n. Разбейте его на минимально возможное количество отрезков, 
чтобы каждое число было не меньше длины отрезка которому оно принадлежит. Длиной отрезка считается количество чисел в нем.

Разбиение массива на отрезки считается корректным, если каждый элемент принадлежит ровно одному отрезку.

Формат ввода
Первая строка содержит одно целое число t (1 ≤ t ≤ 1 000) — количество наборов тестовых данных. 
Затем следуют t наборов тестовых данных.

Первая строка набора тестовых данных содержит одно целое число n (1 ≤ n ≤ 105) — длину массива.

Следующая строка содержит n целых чисел a1, a2, …, an (1 ≤ ai ≤ n) — массив a.

Гарантируется, что сумма n по всем наборам тестовых данных не превосходит 2 ⋅ 105.

Формат вывода
Для каждого набора тестовых данных в первой строке выведите число k — количество отрезков в вашем разбиении.

Затем в следующей строке выведите k чисел len1, len2, …, lenk  — длины отрезков в порядке слева направо.

Пример
Ввод	                            Вывод
3                                   3
5                                   1 2 2
1 3 3 3 2                           3
16                                  1 6 9 
1 9 8 7 6 7 8 9 9 9 9 9 9 9 9 9     3
7                                   2 3 2
7 2 3 4 3 2 7

Примечания
Ответы в примере соответствуют разбиениям:

{[1], [3, 3], [3, 2]}

{[1], [9, 8, 7, 6, 7, 8], [9, 9, 9, 9, 9, 9, 9, 9, 9]}

{[7, 2], [3, 4, 3], [2, 7]}

В первом наборе тестовых данных набор длин {1, 3, 1}, соответствующий разбиению {[1], [3, 3, 3], [2]}, 
также был бы корректным.
*/

#include <iostream>
#include <set>
#include <vector>

using namespace std;

int main() {
    int t;
    cin >> t;
    for (int i = 0; i < t; ++i) {
        int n, cnt;
        cin >> n;
        multiset<int> nums;
        vector<int> res;
        for (int j = 0; j < n; ++j) {
            int num;
            cin >> num;
            nums.insert(num);
        }
        res.push_back(*nums.begin());
        int step = res[0];
        int cntSteps = nums.size();
        for (const auto& num : nums) {
            step--;
            cntSteps--;
            if (step == 0 || cntSteps == 0) {
                step = num;
                res.push_back(step);
                continue;
            }
        }
        int sum = 0;
        for (const auto& c : res)
        {
            sum += c;
        }
        if (sum > cnt) res[res.size() - 1] -= sum - cnt;
        cout << res.size() << endl;
        for (const auto& c : res)
        {
            cout << c << ' ';
        }
        cout << endl;
    }
    return 0;
}