/*
Вася играет в настольную игру «Пираты Баренцева моря», которая посвящена морским битвам. Игровое поле представляет собой квадрат из N×N клеток, на котором расположено 
N кораблей (каждый корабль занимает одну клетку).Вася решил воспользоваться линейной тактикой, для этого ему необходимо выстроить все N кораблей в одном столбце. 
За один ход можно передвинуть один корабль в одну из четырёх соседних по стороне клеток. Номер столбца, в котором будут выстроены корабли, не важен. 
Определите минимальное количество ходов, необходимых для построения кораблей в одном столбце. 
В начале и процессе игры никакие два корабля не могут находиться в одной клетке.

Формат ввода
В первой строке входных данных задаётся число N (1≤N≤100).
В каждой из следующих N строк задаются координаты корабля: сначала номер строки, затем номер столбца (нумерация начинается с единицы).

Формат вывода
Выведите одно число — минимальное количество ходов, необходимое для построения.
Пример
Ввод	        Вывод
3               3
1 2
3 3
1 1

Примечания
В примере необходимо выстроить корабли в столбце номер 2. Для этого необходимо переставить корабль из клетки 3 3 в клетку 3 2 за один ход, 
а корабль из клетки 1 1 в клетку 2 2 за два хода. Существуют и другие варианты перестановки кораблей, однако ни в одном из них нет меньше трёх ходов.

5
3 1
3 2
3 3
3 4
3 5

5
1 1
1 2
1 3
1 4
1 5
*/

#include <iostream>
#include <vector>

using namespace std;

int main() {
    int N;
    cin >> N;
    vector<vector<int>> arr (N);
    for (int i = 0; i < N; ++i) 
        arr[i] = vector<int>(N, 0);

    for (int i = 0; i < N; ++i) {
        int x, y;
        cin >> x >> y;
        arr[x - 1][y - 1] = 1;
    }
    int resSteps = 0;  
    int cntInRow = 0;
    for (int k = 0; k < N; ++k) {       // перебираем столбцы в нахождении минимума шагов
        int nextSteps = 0;
        for (int i = 0; i < N; ++i) { 
            for (int j = k; j >= 0; --j) {
                cntInRow += arr[i][j];
                if (arr[i][j] == 1) nextSteps += cntInRow - 1 + abs(j - k);
            }
            if (cntInRow > 0) cntInRow = 0;
            for (int j = k; j < N; ++j) {
                cntInRow += arr[i][j];
                if (arr[i][j] == 1) nextSteps += cntInRow - 1 + abs(j - k);
            }
            if (cntInRow > 0) cntInRow--;
        }
        if (k == 0) resSteps = nextSteps;
        else resSteps = min(resSteps, nextSteps);
    }
    cout << resSteps << '\n';
    
    return 0;
}