/*
Вы играете в интересную стратегию. У вашего соперника остались всего одна казарма — здание, 
в котором постоянно появляются новые солдаты. Перед атакой у вас есть x солдат. 
За один раунд каждый солдат может убить одного из солдат противника или нанести 1 очко урона казарме 
(вычесть единицу здоровья у казармы). Изначально у вашего оппонента нет солдат. 
Тем не менее, его казарма имеет y единиц здоровья и производит p солдат за раунд.

Ход одного раунда:

Каждый солдат из вашей армии либо убивает одного из солдат вашего противника, либо наносит 1 очко урона казарме. 
Каждый солдат может выбрать своё действие. Когда казарма теряет все свои единицы здоровья, она разрушается.
Ваш противник атакует. Он убьет k ваших солдат, где k — количество оставшихся у противника солдат.
Если казармы еще не разрушены, ваш противник производит p новых солдат.
Ваша задача — разрушить казарму и убить всех солдат противника. 
Если это возможно, посчитайте минимальное количество раундов, которое вам нужно для этого. 
В противном случае выведите -1.

Формат ввода
На вход подаётся три целых числа x, y, p (1 ≤ x, y, p ≤ 5000) — количество ваших солдат на старте игры, 
количество очков здоровья казармы и количество производимых за раунд казармой солдат, соответственно. 
Каждое число расположено в новой строке.

Формат вывода
Если возможно убить всех вражеских солдат и разрушить казарму, выведите минимальное количество раундов, 
необходимых для этого. В противном случае выведите -1.

Пример 1
Ввод	        Вывод
10              4
11
15

Пример 2
Ввод	        Вывод
1               -1
2
1

Пример 3
Ввод	        Вывод
1               1
1
1

Пример 4
Ввод	        Вывод
25              13
200
10

Примечания
В первом примере в первом раунде сначала все ваши солдату атакуют казарму, после этого не происходит ничего, 
потому что у врага нет солдат, затем у врага появляется 15 солдат. 
Во втором раунде один ваш солдат добивает казарму, остальные 9 солдат убивают 9 солдат врага. 
Оставшиеся 6 солдат врага убивают 6 ваших солдат, но армия врага не пополняется, поскольку казарма разрушена. 
В третьем раунде сначала вы убиваете четверых солдат врага, затем враг двоих ваших солдат. 
В последнем, четвертом, раунде вы добиваете двух оставшихся солдат врага.
*/

#include <iostream>
#include <cmath>

using namespace std;

int CalcBattle(int x, int y, int p) {
    int enemies = 0;
    int step = 1;
    int army = x;
    int damage = 0;
    while(true) {
        if (enemies == 0) y -= army;
        else if (y >= army) {
            if (enemies < army) {
                int rem = army - enemies;
                enemies = 0;
                y -= rem;
            } else return -1;
        } else {
            if ((y + enemies) / (double)army <= 1.6181 && (y + enemies) / (double)army >= 1) {
            // if ((y + enemies) / army - (y + enemies + army) / (y + enemies) > 0.001) {
                int rem = army - y;
                y = 0;
                enemies -= rem;
            } else if (enemies < army) {
                    int rem = army - enemies;
                    enemies = 0;
                    y -= rem;
            
            }
        }
        army -= enemies;
        if (army < 0) return -1;
        if (enemies <= 0 && y <= 0) return step;
        if (y > 0) enemies += p;
        //cout << "army = " << army << " enemies = " << enemies << " y = " << y << " step = " << step << endl;
        step++;
    }
}

void run_test(int num, int x, int y, int p, int res) {
    cout << "Тест " << num << " " << "res = " << CalcBattle(x, y, p) << " True: " << res << " " << endl;
}

int main()
{
    int x, y, p;        // x - солдат у нас, y - хп казармы, p - солдат противника за ход
    // cin >> x >> y >> p;
    // cout << CalcBattle(x, y, p) << '\n';
    run_test (1, 1, 1, 1, 1);
    run_test (2, 1, 2, 1, -1);
    run_test (3, 10, 11, 15, 4);
    run_test (4, 300, 301, 485, -1);
    run_test (5, 300, 301, 484, 6);
    run_test (6, 250, 500, 230, 8); //
    run_test (7, 5, 8, 5, 4);
    run_test (8, 25, 200, 10, 13);
    run_test (9, 250, 500, 187, 4);
    run_test (10, 250, 500, 218, 6);
    run_test (11, 2, 3, 2, 3);
    run_test (12, 250, 500, 249, 101);
    run_test (13, 8, 12, 7, 3);
    run_test (14, 2500, 5000, 2499, 961);
    run_test (15, 78, 4934, 77, 4812);
    run_test (16, 78, 126, 77, 5);
    run_test (17, 1661, 4327, 1107, 6);
    run_test (18, 1092, 2892, 950, 11);
    run_test (19, 31, 495, 15, 30);
    run_test (20, 250, 500, 209, 6);
    run_test (21, 3000, 5000, 2998, 79);
    run_test (22, 2500, 5000, 2420, 16);
    return 0;
}